%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%           Generated by MATLAB 9.4 and Fixed-Point Designer 6.1           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
% MATLAB design: 8-point IDWT
% 
% Introduction:
% Performs and returns the Inverse DWT of the input TDM signals as a part of Transmultiplexer operation
% to be transmitted over a communications channel
function [x_out] = mlhdlc_idwt_fixpt(y_in)

fm = get_fimath();

hid = fi([-0.230377813308855 0.714846570552542 -0.630880767929591 -0.0279837694169839 0.187034811718881 0.0308413818359870 -0.0328830116669830 -0.0105974017849973], 1, 14, 13, fm);

% IDWT of the output
x_out = fi(idwt(y_in,hid), 1, 14, 12, fm);

end

function f = idwt(g,h)
% function f = idwt(g,h,NJ); Calculates the IDWT of periodic  g
% with scaling filter  h

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This script/function was created by 
% Abdullah Al Muhit
% contact - almuhit@gmail.com
% website - https://sites.google.com/site/almuhit/
% Please use it at your own risk. Also, Please cite the following paper:
% A A Muhit, M S Islam, and M Othman, “VLSI Implementation of Discrete Wavelet Transform (DWT) for Image Compression”, in Proc. of The Second International Conference on Autonomous Robots and Agents, Palmerston North, New Zealand, pp. 391-395, 2004, ISBN 0-476-00994-4. [PDF]
% A A Muhit, M S Islam, and M Othman, “ Design Design and Analysis of Discrete Wavelet Transform (DWT) for Image Compression Using VHDL”, in Proc. of the International Conference on Parallel and Distributed Processing Techniques and Applications, PDPTA 2005, Volume 1. CSREA Press 2005, pp. 157-160, Las Vegas, Nevada, USA, 2005, ISBN 1-932415-58-0. [PDF]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fm = get_fimath();

L = fi(length(g), 0, 4, 0, fm);   N = fi(length(h), 0, 4, 0, fm);
h0 = fi(h, 1, 14, 13, fm);                                    % Scaling filter
h1 = fi(fliplr(h), 1, 14, 13, fm);  h1(fi(2, 0, 2, 0, fm):fi(2, 0, 2, 0, fm):N) = fi_uminus(h1(fi(2, 0, 2, 0, fm):fi(2, 0, 2, 0, fm):N));   % Wavelet filter
LJ = fi(fi_div_by_shift(L, 1), 0, 3, 0, fm);                                  % Number of SF coeffs.

cu = fi(zeros(1,fi_toint(L+N)), 1, 14, 12, fm);
du = fi(zeros(1,fi_toint(L+N)), 1, 14, 12, fm);

c  = fi(g(fi(1, 0, 1, 0, fm):LJ), 1, 14, 12, fm);                              % Scaling coeffs.
w  = fi(mod(fi(0, 0, 1, 0, fm):fi_signed(fi_div_by_shift(N, 1))-fi(1, 0, 1, 0, fm),LJ)+fi(1, 0, 1, 0, fm), 0, 3, 0, fm);                    % Make periodic
d  = fi(g(LJ+fi(1, 0, 1, 0, fm):L), 1, 14, 12, fm);                            % Wavelet coeffs.
cu(fi(1, 0, 1, 0, fm):fi(2, 0, 2, 0, fm):L+N) = [fi(c, 1, 14, 12, fm) c(1,w)];                  % Up-sample & periodic
du(fi(1, 0, 1, 0, fm):fi(2, 0, 2, 0, fm):L+N) = [fi(d, 1, 14, 12, fm) d(1,w)];                  % Up-sample & periodic
c  = fi(conv(cu,h0) + conv(du,h1), 1, 14, 12, fm);            % Convolve & combine
c  = fi(c(N:fi_signed(N+L)-fi(1, 0, 1, 0, fm)), 1, 14, 12, fm);                           % Periodic part
f = fi(c, 1, 14, 12, fm);                                     % The inverse DWT
end

function [y] = fliplr(x)
%FLIPLR Redefinition of MATLAB  fliplr function
%   Reverses the input array
fm = get_fimath();

N = fi(length(x), 0, 4, 0, fm);
y = fi(zeros(1,fi_toint(N)), 1, 14, 13, fm);
for i=fi(1, 0, 1, 0, fm):N
    y(N-i+fi(1, 0, 1, 0, fm)) = x(i);
end
end

function [y] = conv(x,h)
%CONV Redifinition of discrete convolution function to work with HDL Coder
%   Input: Array of elements to be convolved
%   Output: Discrete convolution of input elements
fm = get_fimath();

n = fi(length(h) + length(x) - 1, 0, 5, 0, fm);
y = fi(zeros(1,fi_toint(n)), 1, 14, 12, fm);

for i=fi(1, 0, 1, 0, fm):n
    sum = fi(0, 1, 14, 12, fm);
    for j=fi(1, 0, 1, 0, fm):i
        if (((i- j+ fi(1, 0, 1, 0, fm)) <= fi(length(h), 0, 4, 0, fm) ) &&(j <= fi(length(x), 0, 5, 0, fm) ))
            sum(:) = sum + x(j)* h(i- j+ fi(1, 0, 1, 0, fm));
        end
    end
    y(i) = sum;
end
end



function y = fi_div_by_shift(a,shift_len)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        fm = fimath( a );
        nt_bs = numerictype( nt.Signed, nt.WordLength + shift_len, nt.FractionLength + shift_len );
        y = bitsra( fi( a, nt_bs, fm ), shift_len );
    else
        y = a/2^shift_len;
    end
end


function y = fi_signed(a)
    coder.inline( 'always' );
    if isfi( a ) && ~(issigned( a ))
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = fi( a, new_nt, fimath( a ) );
    else
        y = a;
    end
end


function y = fi_toint(u)
    coder.inline( 'always' );
    if isfi( u )
        nt = numerictype( u );
        s = nt.SignednessBool;
        wl = nt.WordLength;
        y = int32( fi( u, s, wl, 0, hdlfimath ) );
    else
        y = int32( u );
    end
end


function y = fi_uminus(a)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = -fi( a, new_nt, fimath( a ) );
    else
        y = -a;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
