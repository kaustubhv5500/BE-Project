-- -------------------------------------------------------------
-- 
-- File Name: D:\Downloads\Research\be\code\codegen\mlhdlc_idwt\hdlsrc\mlhdlc_idwt_fixpt.vhd
-- Created: 2021-11-21 21:48:00
-- 
-- Generated by MATLAB 9.4, MATLAB Coder 4.0 and HDL Coder 3.12
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: mlhdlc_idwt_fixpt
-- Source Path: mlhdlc_idwt_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.mlhdlc_idwt_fixpt_pkg.ALL;

ENTITY mlhdlc_idwt_fixpt IS
  PORT( y_in                              :   IN    vector_of_std_logic_vector14(0 TO 7);  -- sfix14_En12 [8]
        x_out                             :   OUT   vector_of_std_logic_vector14(0 TO 7)  -- sfix14_En12 [8]
        );
END mlhdlc_idwt_fixpt;


ARCHITECTURE rtl OF mlhdlc_idwt_fixpt IS

  -- Constants
  CONSTANT nc                             : vector_of_signed14(0 TO 7) := 
    (to_signed(-16#0760#, 14), to_signed(16#16E0#, 14), to_signed(-16#1431#, 14), to_signed(-16#00E6#, 14),
     to_signed(16#05FC#, 14), to_signed(16#00FC#, 14), to_signed(-16#010E#, 14), to_signed(-16#0057#, 14));  -- sfix14 [8]
  CONSTANT nc_0                           : vector_of_signed14(0 TO 7) := 
    (to_signed(-16#0057#, 14), to_signed(-16#010E#, 14), to_signed(16#00FC#, 14), to_signed(16#05FC#, 14),
     to_signed(-16#00E6#, 14), to_signed(-16#1431#, 14), to_signed(16#16E0#, 14), to_signed(-16#0760#, 14));  -- sfix14 [8]
  CONSTANT nc_1_1                         : vector_of_signed14(0 TO 3) := 
    (to_signed(16#010E#, 14), to_signed(-16#05FC#, 14), to_signed(16#1431#, 14), to_signed(16#0760#, 14));  -- sfix14 [4]

  -- Signals
  SIGNAL y_in_signed                      : vector_of_signed14(0 TO 7);  -- sfix14_En12 [8]
  SIGNAL x_out_tmp                        : vector_of_signed14(0 TO 7);  -- sfix14_En12 [8]

BEGIN
  outputgen1: FOR k IN 0 TO 7 GENERATE
    y_in_signed(k) <= signed(y_in(k));
  END GENERATE;

  mlhdlc_idwt_fixpt_1_output : PROCESS (y_in_signed)
    VARIABLE h1 : vector_of_signed14(0 TO 7);
    VARIABLE c : vector_of_signed14(0 TO 3);
    VARIABLE d : vector_of_signed14(0 TO 3);
    VARIABLE cu : vector_of_signed14(0 TO 15);
    VARIABLE du : vector_of_signed14(0 TO 15);
    VARIABLE y : vector_of_signed14(0 TO 22);
    VARIABLE y_0 : vector_of_signed14(0 TO 22);
    VARIABLE i : unsigned(4 DOWNTO 0);
    VARIABLE tmp : unsigned(4 DOWNTO 0);
    VARIABLE sum : signed(13 DOWNTO 0);
    VARIABLE i_1 : unsigned(4 DOWNTO 0);
    VARIABLE tmp_0 : unsigned(4 DOWNTO 0);
    VARIABLE sum_0 : signed(13 DOWNTO 0);
    VARIABLE y_1 : vector_of_signed14(0 TO 22);
    VARIABLE add_cast : vector_of_signed64(0 TO 3);
    VARIABLE cast : vector_of_signed64(0 TO 3);
    VARIABLE cast_0 : vector_of_signed64(0 TO 3);
    VARIABLE add_temp : vector_of_signed32(0 TO 22);
    VARIABLE add_temp_0 : vector_of_signed32(0 TO 22);
    VARIABLE sub_cast : vector_of_signed32(0 TO 22);
    VARIABLE add_temp_1 : vector_of_signed32(0 TO 22);
    VARIABLE cast_1 : vector_of_signed32(0 TO 22);
    VARIABLE sub_cast_0 : vector_of_signed32(0 TO 22);
    VARIABLE add_temp_2 : vector_of_signed32(0 TO 22);
    VARIABLE cast_2 : vector_of_signed32(0 TO 22);
    VARIABLE add_cast_0 : vector_of_signed29(0 TO 22);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 22);
    VARIABLE add_temp_3 : vector_of_unsigned7(0 TO 22);
    VARIABLE sub_cast_2 : vector_of_signed32(0 TO 22);
    VARIABLE mul_temp : vector_of_signed28(0 TO 22);
    VARIABLE add_cast_1 : vector_of_signed29(0 TO 22);
    VARIABLE add_temp_4 : vector_of_signed29(0 TO 22);
    VARIABLE add_cast_2 : vector_of_signed29(0 TO 22);
    VARIABLE sub_cast_3 : vector_of_signed32(0 TO 22);
    VARIABLE add_temp_5 : vector_of_unsigned7(0 TO 22);
    VARIABLE sub_cast_4 : vector_of_signed32(0 TO 22);
    VARIABLE mul_temp_0 : vector_of_signed28(0 TO 22);
    VARIABLE add_cast_3 : vector_of_signed29(0 TO 22);
    VARIABLE add_temp_6 : vector_of_signed29(0 TO 22);
  BEGIN
    --HDL code generation from MATLAB function: mlhdlc_idwt_fixpt
    --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    --                                                                          %
    --           Generated by MATLAB 9.4 and Fixed-Point Designer 6.1           %
    --                                                                          %
    --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    -- MATLAB design: 8-point IDWT
    -- 
    -- Introduction:
    -- Performs and returns the Inverse DWT of the input TDM signals as a part of Transmultiplexer operation
    -- to be transmitted over a communications channel
    -- IDWT of the output
    -- function f = idwt(g,h,NJ); Calculates the IDWT of periodic  g
    -- with scaling filter  h
    --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    -- This script/function was created by 
    -- Abdullah Al Muhit
    -- contact - almuhit@gmail.com
    -- website - https://sites.google.com/site/almuhit/
    -- Please use it at your own risk. Also, Please cite the following paper:
    -- A A Muhit, M S Islam, and M Othman, “VLSI Implementation of Discrete Wavelet Transform (DWT) for Image Compression”, in Proc. of The Second International Conference on Autonomous Robots and Agents, Palmerston North, New Zealand, pp. 391-395, 2004, ISBN 0-476-00994-4. [PDF]
    -- A A Muhit, M S Islam, and M Othman, “ Design Design and Analysis of Discrete Wavelet Transform (DWT) for Image Compression Using VHDL”, in Proc. of the International Conference on Parallel and Distributed Processing Techniques and Applications, PDPTA 2005, Volume 1. CSREA Press 2005, pp. 157-160, Las Vegas, Nevada, USA, 2005, ISBN 1-932415-58-0. [PDF]
    --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    -- Scaling filter
    h1 := nc_0;
    -- Wavelet filter
    -- Number of SF coeffs.
    -- Scaling coeffs.
    -- Make periodic

    FOR t_0 IN 0 TO 3 LOOP
      add_cast(t_0) := resize(to_signed(t_0, 32) & '0', 64);
      h1(to_integer(1 + resize(add_cast(t_0), 32))) := nc_1_1(t_0);
      c(t_0) := y_in_signed(t_0);
      d(t_0) := y_in_signed(4 + t_0);
    END LOOP;

    -- Wavelet coeffs.
    cu := (OTHERS => to_signed(16#0000#, 14));

    FOR t_1 IN 0 TO 3 LOOP
      cast(t_1) := resize(to_signed(t_1, 32) & '0', 64);
      cu(to_integer(resize(cast(t_1), 31))) := c(t_1);
      cu(2 * (t_1 + 4)) := c(t_1);
    END LOOP;

    -- Up-sample & periodic
    du := (OTHERS => to_signed(16#0000#, 14));

    FOR t_2 IN 0 TO 3 LOOP
      cast_0(t_2) := resize(to_signed(t_2, 32) & '0', 64);
      du(to_integer(resize(cast_0(t_2), 31))) := d(t_2);
      du(2 * (t_2 + 4)) := d(t_2);
    END LOOP;

    -- Up-sample & periodic
    --CONV Redifinition of discrete convolution function to work with HDL Coder
    --   Input: Array of elements to be convolved
    --   Output: Discrete convolution of input elements
    y := (OTHERS => to_signed(16#0000#, 14));
    --CONV Redifinition of discrete convolution function to work with HDL Coder
    --   Input: Array of elements to be convolved
    --   Output: Discrete convolution of input elements

    FOR i_0 IN 0 TO 22 LOOP
      add_temp(i_0) := to_signed(i_0 + 1, 32);
      i := unsigned(add_temp(i_0)(4 DOWNTO 0));
      sum := to_signed(16#0000#, 14);

      FOR j IN 0 TO 22 LOOP
        add_temp_1(j) := to_signed(j + 1, 32);
        tmp := unsigned(add_temp_1(j)(4 DOWNTO 0));
        cast_1(j) := signed(resize(i, 32));
        IF to_signed(j + 1, 32) <= cast_1(j) THEN 
          IF ((resize(resize(i, 6) - resize(tmp, 6), 7) + to_unsigned(16#01#, 7)) <= to_unsigned(16#08#, 7)) AND (tmp <= to_unsigned(16#10#, 5)) THEN 
            add_cast_0(j) := resize(sum & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 29);
            sub_cast_1(j) := signed(resize(tmp, 32));
            add_temp_3(j) := resize(resize(i, 6) - resize(tmp, 6), 7) + to_unsigned(16#01#, 7);
            sub_cast_2(j) := signed(resize(add_temp_3(j), 32));
            mul_temp(j) := cu(to_integer(sub_cast_1(j) - 1)) * nc(to_integer(sub_cast_2(j) - 1));
            add_cast_1(j) := resize(mul_temp(j), 29);
            add_temp_4(j) := add_cast_0(j) + add_cast_1(j);
            sum := add_temp_4(j)(26 DOWNTO 13);
          END IF;
        END IF;
      END LOOP;

      sub_cast(i_0) := signed(resize(i, 32));
      y(to_integer(sub_cast(i_0) - 1)) := sum;
      y_0(i_0) := to_signed(16#0000#, 14);
    END LOOP;


    FOR i_2 IN 0 TO 22 LOOP
      add_temp_0(i_2) := to_signed(i_2 + 1, 32);
      i_1 := unsigned(add_temp_0(i_2)(4 DOWNTO 0));
      sum_0 := to_signed(16#0000#, 14);

      FOR j_0 IN 0 TO 22 LOOP
        add_temp_2(j_0) := to_signed(j_0 + 1, 32);
        tmp_0 := unsigned(add_temp_2(j_0)(4 DOWNTO 0));
        cast_2(j_0) := signed(resize(i_1, 32));
        IF to_signed(j_0 + 1, 32) <= cast_2(j_0) THEN 
          IF ((resize(resize(i_1, 6) - resize(tmp_0, 6), 7) + to_unsigned(16#01#, 7)) <= to_unsigned(16#08#, 7)) AND (tmp_0 <= to_unsigned(16#10#, 5)) THEN 
            add_cast_2(j_0) := resize(sum_0 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 29);
            sub_cast_3(j_0) := signed(resize(tmp_0, 32));
            add_temp_5(j_0) := resize(resize(i_1, 6) - resize(tmp_0, 6), 7) + to_unsigned(16#01#, 7);
            sub_cast_4(j_0) := signed(resize(add_temp_5(j_0), 32));
            mul_temp_0(j_0) := du(to_integer(sub_cast_3(j_0) - 1)) * h1(to_integer(sub_cast_4(j_0) - 1));
            add_cast_3(j_0) := resize(mul_temp_0(j_0), 29);
            add_temp_6(j_0) := add_cast_2(j_0) + add_cast_3(j_0);
            sum_0 := add_temp_6(j_0)(26 DOWNTO 13);
          END IF;
        END IF;
      END LOOP;

      sub_cast_0(i_2) := signed(resize(i_1, 32));
      y_0(to_integer(sub_cast_0(i_2) - 1)) := sum_0;
    END LOOP;

    -- Convolve & combine
    -- Periodic part
    -- The inverse DWT

    FOR t_3 IN 0 TO 22 LOOP
      y_1(t_3) := y(t_3) + y_0(t_3);
    END LOOP;

    x_out_tmp(0 TO 7) <= y_1(7 TO 14);
  END PROCESS mlhdlc_idwt_fixpt_1_output;


  outputgen: FOR k IN 0 TO 7 GENERATE
    x_out(k) <= std_logic_vector(x_out_tmp(k));
  END GENERATE;

END rtl;

