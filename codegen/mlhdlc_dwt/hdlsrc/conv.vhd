-- -------------------------------------------------------------
-- 
-- File Name: D:\Downloads\Research\be\code\codegen\mlhdlc_dwt\hdlsrc\conv.vhd
-- Created: 2022-04-28 14:31:24
-- 
-- Generated by MATLAB 9.4, MATLAB Coder 4.0 and HDL Coder 3.12
-- 
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: conv
-- Source Path: 
-- Hierarchy Level: 2
-- 
-- HDL code generation from MATLAB function: mlhdlc_dwt_fixpt
-- 
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- 
--                                                                          %
-- 
--           Generated by MATLAB 9.4 and Fixed-Point Designer 6.1           %
-- 
--                                                                          %
-- 
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- 
-- MATLAB design: 8-point Discrete WT
-- 
-- 
-- 
-- Introduction:
-- 
-- Performs and returns the DWT of the input TDM signals as a part of Transmultiplexer operation
-- 
-- to be transmitted over a communications channel
-- 
-- 'mlhdlc_dwt_fixpt:14' fm = get_fimath();
-- 
-- 'mlhdlc_dwt_fixpt:16' hid = fi([-0.230377813308855 0.714846570552542 -0.630880767929591 -0.0279837694169839 0.187034811718881 
-- 0.0308413818359870 -0.0328830116669830 -0.0105974017849973], 1, 14, 13, fm)
-- 
-- declare and initialize the delay registers
-- 
-- persistent ud1 ud2 ud3 ud4 ud5 ud6 ud7 ud8;
-- 
-- if isempty(ud1)
-- 
--     ud1 = 0; ud2 = 0; ud3 = 0; ud4 = 0; ud5 = 0; ud6 = 0; ud7 = 0; ud8 = 0;
-- 
-- end
-- 
-- access the previous value of states/registers
-- 
-- a1 = ud1;
-- 
-- a2 = ud2;
-- 
-- a3 = ud3;
-- 
-- a4 = ud4;
-- 
-- a5 = ud5;
-- 
-- a6 = ud6;
-- 
-- a7 = ud7;
-- 
-- a8 = ud8;
-- 
-- x = [a1 a2 a3 a4 a5 a6 a7 a8];
-- 
-- DWT of the output
-- 
-- 'mlhdlc_dwt_fixpt:37' y_out = fi(dwt(x_in,hid), 1, 14, 12, fm);
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.mlhdlc_dwt_fixpt_pkg.ALL;

ENTITY conv IS
  PORT( c                                 :   IN    vector_of_std_logic_vector14(0 TO 14);  -- sfix14_En12 [15]
        h1                                :   IN    vector_of_std_logic_vector14(0 TO 7);  -- sfix14_En13 [8]
        tmp                               :   OUT   vector_of_std_logic_vector14(0 TO 21)  -- sfix14_En12 [22]
        );
END conv;


ARCHITECTURE rtl OF conv IS

  -- Signals
  SIGNAL c_signed                         : vector_of_signed14(0 TO 14);  -- sfix14_En12 [15]
  SIGNAL h1_signed                        : vector_of_signed14(0 TO 7);  -- sfix14_En13 [8]
  SIGNAL y_1                              : vector_of_signed14(0 TO 21);  -- sfix14_En12 [22]

BEGIN
  outputgen2: FOR k IN 0 TO 14 GENERATE
    c_signed(k) <= signed(c(k));
  END GENERATE;

  outputgen1: FOR k IN 0 TO 7 GENERATE
    h1_signed(k) <= signed(h1(k));
  END GENERATE;

  -- HDL code generation from MATLAB function: conv
  -- 
  -- 'mlhdlc_dwt_fixpt:115' y(i) = sum;
  -- 
  -- 'mlhdlc_dwt_fixpt:112' sum(:) = sum + x(j)* h(i- j+ fi(1, 0, 1, 0, fm));
  -- 
  -- 'mlhdlc_dwt_fixpt:111' if (((i- j+ fi(1, 0, 1, 0, fm)) <= fi(length(h), 0, 4, 0, fm) ) &&(j <= fi(length(x), 0, 
  -- 4, 0, fm) )
  -- 
  -- 'mlhdlc_dwt_fixpt:110' for j=fi(1, 0, 1, 0, fm):i
  -- 
  -- 'mlhdlc_dwt_fixpt:109' sum = fi(0, 1, 14, 12, fm);
  -- 
  -- CONV Redifinition of discrete convolution function to work with HDL Coder
  -- 
  --   Input: Array of elements to be convolved
  -- 
  --   Output: Discrete convolution of input elements
  -- 
  -- 'mlhdlc_dwt_fixpt:103' fm = get_fimath();
  -- 
  -- 'mlhdlc_dwt_fixpt:105' n = fi(length(h) + length(x) - 1, 0, 5, 0, fm);
  -- 
  -- 'mlhdlc_dwt_fixpt:106' y = fi(zeros(1,fi_toint(n)), 1, 14, 12, fm);
  -- 
  -- 'mlhdlc_dwt_fixpt:108' for i=fi(1, 0, 1, 0, fm):n
  p1_output : PROCESS (c_signed, h1_signed)
    VARIABLE y : vector_of_signed14(0 TO 21);
    VARIABLE i_0 : unsigned(4 DOWNTO 0);
    VARIABLE sum : signed(13 DOWNTO 0);
    VARIABLE tmp1 : unsigned(4 DOWNTO 0);
    VARIABLE sum_0 : signed(13 DOWNTO 0);
    VARIABLE sum_1 : signed(13 DOWNTO 0);
    VARIABLE add_temp : vector_of_signed32(0 TO 21);
    VARIABLE sub_cast : vector_of_signed32(0 TO 21);
    VARIABLE add_temp_0 : vector_of_signed32(0 TO 21);
    VARIABLE cast : vector_of_signed32(0 TO 21);
    VARIABLE add_cast : vector_of_signed29(0 TO 21);
    VARIABLE sub_cast_0 : vector_of_signed32(0 TO 21);
    VARIABLE add_temp_1 : vector_of_unsigned7(0 TO 21);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 21);
    VARIABLE mul_temp : vector_of_signed28(0 TO 21);
    VARIABLE add_cast_0 : vector_of_signed29(0 TO 21);
    VARIABLE add_temp_2 : vector_of_signed29(0 TO 21);
  BEGIN
    y := (OTHERS => to_signed(16#0000#, 14));

    FOR i IN 0 TO 21 LOOP
      add_temp(i) := to_signed(i + 1, 32);
      i_0 := unsigned(add_temp(i)(4 DOWNTO 0));
      sum := to_signed(16#0000#, 14);

      FOR j IN 0 TO 21 LOOP
        add_temp_0(j) := to_signed(j + 1, 32);
        tmp1 := unsigned(add_temp_0(j)(4 DOWNTO 0));
        cast(j) := signed(resize(i_0, 32));
        IF to_signed(j + 1, 32) <= cast(j) THEN 
          IF ((resize(resize(i_0, 6) - resize(tmp1, 6), 7) + to_unsigned(16#01#, 7)) <= to_unsigned(16#08#, 7)) AND (tmp1 <= to_unsigned(16#0F#, 5)) THEN 
            add_cast(j) := resize(sum & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 29);
            sub_cast_0(j) := signed(resize(tmp1, 32));
            add_temp_1(j) := resize(resize(i_0, 6) - resize(tmp1, 6), 7) + to_unsigned(16#01#, 7);
            sub_cast_1(j) := signed(resize(add_temp_1(j), 32));
            mul_temp(j) := c_signed(to_integer(sub_cast_0(j) - 1)) * h1_signed(to_integer(sub_cast_1(j) - 1));
            add_cast_0(j) := resize(mul_temp(j), 29);
            add_temp_2(j) := add_cast(j) + add_cast_0(j);
            sum_0 := add_temp_2(j)(26 DOWNTO 13);
          ELSE 
            sum_0 := sum;
          END IF;
          sum_1 := sum_0;
        ELSE 
          sum_1 := sum;
        END IF;
        sum := sum_1;
      END LOOP;

      sub_cast(i) := signed(resize(i_0, 32));
      y(to_integer(sub_cast(i) - 1)) := sum;
    END LOOP;

    y_1 <= y;
  END PROCESS p1_output;


  outputgen: FOR k IN 0 TO 21 GENERATE
    tmp(k) <= std_logic_vector(y_1(k));
  END GENERATE;

END rtl;

